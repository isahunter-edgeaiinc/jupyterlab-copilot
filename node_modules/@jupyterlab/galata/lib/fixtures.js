"use strict";
/* eslint-disable @typescript-eslint/ban-ts-comment */
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = void 0;
const test_1 = require("@playwright/test");
const path = __importStar(require("path"));
const contents_1 = require("./contents");
const galata_1 = require("./galata");
/**
 * JupyterLab customized test.
 */
// @ts-ignore
exports.test = test_1.test.extend({
    /**
     * `baseURL` used for all pages in the test. Takes priority over `contextOptions`.
     * @see BrowserContextOptions
     *
     * It can also be set with `TARGET_URL` environment variable and default to `http://localhost:8888`.
     */
    baseURL: async ({ baseURL }, use) => {
        var _a;
        await use((_a = baseURL !== null && baseURL !== void 0 ? baseURL : process.env.TARGET_URL) !== null && _a !== void 0 ? _a : 'http://localhost:8888');
    },
    /**
     * Application URL path fragment.
     *
     * Default: /lab
     */
    appPath: ['/lab', { option: true }],
    /**
     * Whether to go to JupyterLab page within the fixture or not.
     *
     * Default: true.
     *
     * Note: Setting it to false allows to register new route mock-ups for example.
     */
    autoGoto: [true, { option: true }],
    /**
     * Kernels created during the test.
     *
     * Possible values are:
     * - null: The kernels API won't be mocked
     * - Map<string, Kernel.IModel>: The kernels created during a test.
     *
     * By default the kernels created during a test will be tracked and disposed at the end.
     */
    kernels: async ({ request }, use) => {
        const kernels = new Map();
        await use(kernels);
        if (kernels.size > 0) {
            await galata_1.galata.Mock.clearRunners(request, [...kernels.keys()], 'kernels');
        }
    },
    /**
     * Mock JupyterLab config in-memory or not.
     *
     * Possible values are:
     * - true (default): JupyterLab config will be mocked on a per test basis
     * - false: JupyterLab config won't be mocked (Be careful it will write config in local files)
     * - Record<string, JSONObject>: Initial JupyterLab data config - Mapping (config section, value).
     *
     * By default the config is stored in-memory.
     */
    mockConfig: [true, { option: true }],
    /**
     * Mock JupyterLab state in-memory or not.
     *
     * Possible values are:
     * - true (default): JupyterLab state will be mocked on a per test basis
     * - false: JupyterLab state won't be mocked (Be careful it will write state in local files)
     * - Record<string, unknown>: Initial JupyterLab data state - Mapping (state key, value).
     *
     * By default the state is stored in-memory
     */
    mockState: [true, { option: true }],
    /**
     * Mock JupyterLab settings in-memory or not.
     *
     * Possible values are:
     * - true: JupyterLab settings will be mocked on a per test basis
     * - false: JupyterLab settings won't be mocked (Be careful it may write settings local files)
     * - Record<string, unknown>: Mapping {pluginId: settings} that will be default user settings
     *
     * The default value is `galata.DEFAULT_SETTINGS`
     *
     * By default the settings are stored in-memory. However the
     * they are still initialized with the hard drive values.
     */
    mockSettings: [galata_1.galata.DEFAULT_SETTINGS, { option: true }],
    /**
     * Mock JupyterLab user in-memory or not.
     *
     * Possible values are:
     * - true (default): JupyterLab user will be mocked on a per test basis
     * - false: JupyterLab user won't be mocked (It will be a random user so snapshots won't match)
     * - Record<string, unknown>: Initial JupyterLab user - Mapping (user attribute, value).
     *
     * By default the user is stored in-memory.
     */
    mockUser: [true, { option: true }],
    /**
     * Galata can keep the uploaded and created files in ``tmpPath`` on
     * the server root for debugging purpose. By default the files are
     * always deleted.
     *
     * - 'off' - ``tmpPath`` is deleted after each tests
     * - 'on' - ``tmpPath`` is never deleted
     * - 'only-on-failure' - ``tmpPath`` is deleted except if a test failed or timed out.
     */
    serverFiles: ['off', { option: true }],
    /**
     * Sessions created during the test.
     *
     * Possible values are:
     * - null: The sessions API won't be mocked
     * - Map<string, Session.IModel>: The sessions created during a test.
     *
     * By default the sessions created during a test will be tracked and disposed at the end.
     */
    sessions: async ({ request }, use) => {
        const sessions = new Map();
        await use(sessions);
        if (sessions.size > 0) {
            await galata_1.galata.Mock.clearRunners(request, [...sessions.keys()], 'sessions');
        }
    },
    /**
     * Terminals created during the test.
     *
     * Possible values are:
     * - null: The Terminals API won't be mocked
     * - Map<string, TerminalAPI.IModel>: The Terminals created during a test.
     *
     * By default the Terminals created during a test will be tracked and disposed at the end.
     */
    terminals: async ({ request }, use) => {
        const terminals = new Map();
        await use(terminals);
        if (terminals.size > 0) {
            await galata_1.galata.Mock.clearRunners(request, [...terminals.keys()], 'terminals');
        }
    },
    /**
     * Unique test temporary path created on the server.
     *
     * Note: if you override this string, you will need to take care of creating the
     * folder and cleaning it.
     */
    tmpPath: async ({ request, serverFiles }, use, testInfo) => {
        // Remove appended retry part for reproducibility
        const testFolder = path
            .basename(testInfo.outputDir)
            .replace(/-retry\d+$/i, '');
        const contents = new contents_1.ContentsHelper(request);
        if (await contents.directoryExists(testFolder)) {
            await contents.deleteDirectory(testFolder);
        }
        // Create the test folder on the server
        await contents.createDirectory(testFolder);
        await use(testFolder);
        // Delete the test folder on the server
        // If serverFiles is 'on' or 'only-on-failure', keep the server files for the test
        if (serverFiles === 'off' ||
            (serverFiles === 'only-on-failure' &&
                (testInfo.status === 'passed' || testInfo.status === 'skipped'))) {
            await contents.deleteDirectory(testFolder);
        }
    },
    /**
     * Wait for the application page to be ready
     *
     * @param page Playwright Page model
     * @param helpers JupyterLab helpers
     */
    waitForApplication: async ({ baseURL }, use) => {
        const waitIsReady = async (page, helpers) => {
            await page.locator('#jupyterlab-splash').waitFor({ state: 'detached' });
            await helpers.waitForCondition(() => {
                return helpers.activity.isTabActive('Launcher');
            });
            // Oddly current tab is not always set to active
            if (!(await helpers.isInSimpleMode())) {
                await helpers.activity.activateTab('Launcher');
            }
        };
        await use(waitIsReady);
    },
    /**
     * JupyterLab test page.
     *
     * It brings the following feature on top of Playwright Page object:
     * - Goto to JupyterLab URL and wait for the application to be ready (autoGoto == true)
     * - Helpers for JupyterLab
     * - Settings mock-up
     * - State mock-up
     * - Track sessions and terminals opened during a test to close them at the end
     *
     * Note: If autoGoto is true, the filebrowser will be set inside tmpPath.
     * Nothing is preventing you to navigate to some other folders.
     * So you must avoid creating files outside that directory to avoid
     * coupling effects between tests.
     */
    // @ts-ignore
    page: async ({ appPath, autoGoto, baseURL, kernels, mockConfig, mockSettings, mockState, mockUser, page, sessions, terminals, tmpPath, waitForApplication }, use) => {
        await use(await galata_1.galata.initTestPage(appPath, autoGoto, baseURL, mockConfig, mockSettings, mockState, mockUser, page, sessions, terminals, tmpPath, waitForApplication, kernels));
    }
});
//# sourceMappingURL=fixtures.js.map