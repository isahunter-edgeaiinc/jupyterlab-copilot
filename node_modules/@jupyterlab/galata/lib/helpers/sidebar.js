"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SidebarHelper = void 0;
const Utils = __importStar(require("../utils"));
/**
 * Sidebar helpers
 */
class SidebarHelper {
    constructor(page, menu) {
        this.page = page;
        this.menu = menu;
        /**
         * Whether a sidebar is opened or not
         *
         * @param side Sidebar side
         * @returns Opened status
         */
        this.isOpen = async (side = 'left') => {
            return (await this.getContentPanelLocator(side).count()) > 0;
        };
        /**
         * Get the position of a given tab
         *
         * @param id Tab id
         * @returns Tab position
         */
        this.getTabPosition = async (id) => {
            return await this.page.evaluate(async ({ tabSelector }) => {
                const tabButton = document.querySelector(tabSelector);
                if (!tabButton) {
                    return null;
                }
                const sideBar = tabButton.closest('.jp-SideBar');
                if (!sideBar) {
                    return null;
                }
                return sideBar.classList.contains('jp-mod-right') ? 'right' : 'left';
            }, { tabSelector: this.buildTabSelector(id) });
        };
    }
    /**
     * Whether a given tab is opened or not
     *
     * @param id Tab id
     * @returns Tab opened status
     */
    async isTabOpen(id) {
        const tabButton = this.page.locator(`${this.buildTabSelector(id)}.lm-mod-current`);
        return (await tabButton.count()) > 0;
    }
    /**
     * Move a given tab to left side
     *
     * @param id Tab id
     */
    async moveTabToLeft(id) {
        await this.setTabPosition(id, 'left');
    }
    /**
     * Move a given tab to the right side
     *
     * @param id Tab id
     */
    async moveTabToRight(id) {
        await this.setTabPosition(id, 'right');
    }
    /**
     * Set the position of a given tab
     *
     * @param id Tab id
     * @param side Sidebar side
     */
    async setTabPosition(id, side) {
        const position = await this.getTabPosition(id);
        if (position === side) {
            return;
        }
        await this.toggleTabPosition(id);
        await Utils.waitForCondition(async () => {
            return (await this.getTabPosition(id)) === side;
        });
    }
    /**
     * Toggle a given tab position
     *
     * @param id Tab id
     */
    async toggleTabPosition(id) {
        const tab = this.getTabLocator(id);
        if (!(await tab.count())) {
            return;
        }
        await tab.click({ button: 'right' });
        const switchMenuItem = this.page.locator('.lm-Menu-content .lm-Menu-item[data-command="sidebar:switch"]');
        await switchMenuItem.waitFor({ state: 'visible' });
        if (await switchMenuItem.count()) {
            await switchMenuItem.click();
        }
    }
    /**
     * Move all tabs to the left side
     */
    async moveAllTabsToLeft() {
        await this.page.evaluate(async ({ pluginId }) => {
            const settingRegistry = (await window.galata.getPlugin(pluginId));
            const SHELL_ID = '@jupyterlab/application-extension:shell';
            const sidebars = {
                Debugger: 'left',
                'Property Inspector': 'left',
                'Extension Manager': 'left',
                'File Browser': 'left',
                'Sessions and Tabs': 'left',
                'Table of Contents': 'left'
            };
            const currentLayout = (await settingRegistry.get(SHELL_ID, 'layout'));
            await settingRegistry.set(SHELL_ID, 'layout', {
                single: { ...currentLayout.single, ...sidebars },
                multiple: { ...currentLayout.multiple, ...sidebars }
            });
        }, {
            pluginId: '@jupyterlab/apputils-extension:settings'
        });
        await this.page.waitForFunction(() => {
            const rightStack = document.getElementById('jp-right-stack');
            return (rightStack === null || rightStack === void 0 ? void 0 : rightStack.childElementCount) === 0;
        });
    }
    /**
     * Get the handle on a given tab
     *
     * @param id Tab id
     * @returns Tab handle
     *
     * @deprecated You should use locator instead {@link getTabLocator}
     */
    async getTab(id) {
        return await this.getTabLocator(id).elementHandle();
    }
    /**
     * Get the locator on a given tab
     *
     * @param id Tab id
     * @returns Tab locator
     */
    getTabLocator(id) {
        return this.page.locator(this.buildTabSelector(id));
    }
    /**
     * Open a given tab
     *
     * @param id Tab id
     */
    async openTab(id) {
        const isOpen = await this.isTabOpen(id);
        if (isOpen) {
            return;
        }
        const tabButton = this.getTabLocator(id);
        if (!((await tabButton.count()) === 1)) {
            throw new Error(`Unable to find the tab ${id} button`);
        }
        await tabButton.click();
        await this._waitForTabActivate(tabButton);
    }
    /**
     * Get the handle on a sidebar content panel
     *
     * @param side Position
     * @returns Panel handle
     *
     * @deprecated You should use locator instead {@link getContentPanelLocator}
     */
    async getContentPanel(side = 'left') {
        return await this.getContentPanelLocator(side).elementHandle();
    }
    /**
     * Get the locator on a sidebar content panel
     *
     * @param side Position
     * @returns Panel handle
     */
    getContentPanelLocator(side = 'left') {
        return this.page.locator(`#jp-${side}-stack .lm-StackedPanel-child:not(.lm-mod-hidden)`);
    }
    /**
     * Get the tab bar of the sidebar
     *
     * @param side Position
     * @returns Tab bar handle
     *
     * @deprecated You should use locator instead {@link getTabBarLocator}
     */
    async getTabBar(side = 'left') {
        return await this.getTabBarLocator(side).elementHandle();
    }
    /**
     * Get the locator of the tab bar of the sidebar
     *
     * @param side Position
     * @returns Tab bar locator
     */
    getTabBarLocator(side = 'left') {
        return this.page.locator(`.jp-SideBar.jp-mod-${side}`);
    }
    /**
     * Open a given sidebar
     *
     * @param side Position
     */
    async open(side = 'left') {
        const isOpen = await this.isOpen(side);
        if (isOpen) {
            return;
        }
        await this.menu.clickMenuItem(`View>Appearance>Show ${side === 'left' ? 'Left' : 'Right'} Sidebar`);
        await Utils.waitForCondition(async () => {
            return await this.isOpen(side);
        });
    }
    /**
     * Close a given sidebar
     *
     * @param side Position
     */
    async close(side = 'left') {
        const isOpen = await this.isOpen(side);
        if (!isOpen) {
            return;
        }
        await this.menu.clickMenuItem(`View>Appearance>Show ${side === 'left' ? 'Left' : 'Right'} Sidebar`);
        await Utils.waitForCondition(async () => {
            return !(await this.isOpen(side));
        });
    }
    /**
     * Set the sidebar width
     *
     * @param width Sidebar width in pixels
     * @param side Which sidebar to set: 'left' or 'right'
     */
    async setWidth(width = 251, side = 'left') {
        if (!(await this.isOpen(side))) {
            return false;
        }
        const handles = this.page.locator('#jp-main-split-panel > .lm-SplitPanel-handle:not(.lm-mod-hidden)');
        const splitHandle = side === 'left'
            ? await handles.first().elementHandle()
            : await handles.last().elementHandle();
        const handleBBox = await splitHandle.boundingBox();
        await this.page.mouse.move(handleBBox.x + 0.5 * handleBBox.width, handleBBox.y + 0.5 * handleBBox.height);
        await this.page.mouse.down();
        await this.page.mouse.move(side === 'left'
            ? 33 + width
            : this.page.viewportSize().width - 33 - width, handleBBox.y + 0.5 * handleBBox.height);
        await this.page.mouse.up();
        return true;
    }
    /**
     * Get the selector for a given tab
     *
     * @param id Tab id
     * @returns Selector
     */
    buildTabSelector(id) {
        return `.lm-TabBar.jp-SideBar .lm-TabBar-content li.lm-TabBar-tab[data-id="${id}"]`;
    }
    async _waitForTabActivate(tab, activate = true) {
        await Utils.waitForCondition(async () => {
            const current = (await Utils.getLocatorClassList(tab)).includes('lm-mod-current');
            return activate ? current : !current;
        });
    }
}
exports.SidebarHelper = SidebarHelper;
//# sourceMappingURL=sidebar.js.map