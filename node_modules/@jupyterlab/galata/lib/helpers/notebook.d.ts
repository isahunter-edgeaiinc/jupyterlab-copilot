import type * as nbformat from '@jupyterlab/nbformat';
import { ElementHandle, Locator, Page } from '@playwright/test';
import { ContentsHelper } from '../contents';
import type { INotebookRunCallback } from '../extension';
import { galata } from '../galata';
import { ActivityHelper } from './activity';
import { FileBrowserHelper } from './filebrowser';
import { MenuHelper } from './menu';
/**
 * Notebook helpers
 */
export declare class NotebookHelper {
    readonly page: Page;
    readonly activity: ActivityHelper;
    readonly contents: ContentsHelper;
    readonly filebrowser: FileBrowserHelper;
    readonly menu: MenuHelper;
    constructor(page: Page, activity: ActivityHelper, contents: ContentsHelper, filebrowser: FileBrowserHelper, menu: MenuHelper);
    /**
     * Whether a given notebook is opened or not
     *
     * @param name Notebook name
     * @returns Notebook opened status
     */
    isOpen(name: string): Promise<boolean>;
    /**
     * Whether a given notebook is active or not
     *
     * @param name Notebook name
     * @returns Notebook active status
     */
    isActive(name: string): Promise<boolean>;
    /**
     * Whether a notebook is currently active or not
     *
     * @returns Notebook active status
     */
    isAnyActive(): Promise<boolean>;
    /**
     * Open a notebook from its name
     *
     * The notebook needs to exist in the current folder.
     *
     * @param name Notebook name
     * @returns Action success status
     */
    open(name: string): Promise<boolean>;
    /**
     * Open a notebook from its path
     *
     * The notebook do not need to exist in the current folder
     *
     * @param filePath Notebook path
     * @returns Action success status
     */
    openByPath(filePath: string): Promise<boolean>;
    /**
     * Get the handle to a notebook panel
     *
     * @param name Notebook name
     * @returns Handle to the Notebook panel
     *
     * @deprecated You should use locator instead {@link getNotebookInPanelLocator}
     */
    getNotebookInPanel(name?: string): Promise<ElementHandle<Element> | null>;
    /**
     * Get the locator to a notebook panel
     *
     * @param name Notebook name
     * @returns Locator to the Notebook panel
     */
    getNotebookInPanelLocator(name?: string): Promise<Locator | null>;
    /**
     * Get the handle to a notebook toolbar
     *
     * @param name Notebook name
     * @returns Handle to the Notebook toolbar
     *
     * @deprecated You should use locator instead {@link getToolbarLocator}
     */
    getToolbar(name?: string): Promise<ElementHandle<Element> | null>;
    /**
     * Get the notebook toolbar locator
     *
     * @param name Notebook name
     * @returns Locator to the Notebook toolbar
     */
    getToolbarLocator(name?: string): Promise<Locator | null>;
    /**
     * Get the handle to a notebook toolbar item from its index
     *
     * @param itemIndex Toolbar item index
     * @param notebookName Notebook name
     * @returns Handle to the notebook toolbar item
     *
     * @deprecated You should use locator instead {@link getToolbarItemLocatorByIndex}
     */
    getToolbarItemByIndex(itemIndex: number, notebookName?: string): Promise<ElementHandle<Element> | null>;
    /**
     * Get the locator to a notebook toolbar item from its index
     *
     * @param itemIndex Toolbar item index
     * @param notebookName Notebook name
     * @returns locator to the notebook toolbar item
     */
    getToolbarItemLocatorByIndex(itemIndex: number, notebookName?: string): Promise<Locator | null>;
    /**
     * Get the handle to a notebook toolbar item from its id
     *
     * @param itemId Toolbar item id
     * @param notebookName Notebook name
     * @returns Handle to the notebook toolbar item
     *
     * @deprecated You should use locator instead {@link getToolbarItemLocator}
     */
    getToolbarItem(itemId: galata.NotebookToolbarItemId, notebookName?: string): Promise<ElementHandle<Element> | null>;
    /**
     * Get the locator to a notebook toolbar item from its id
     *
     * @param itemId Toolbar item id
     * @param notebookName Notebook name
     * @returns Locator to the notebook toolbar item
     */
    getToolbarItemLocator(itemId: galata.NotebookToolbarItemId, notebookName?: string): Promise<Locator | null>;
    /**
     * Click on a notebook toolbar item
     *
     * @param itemId Toolbar item id
     * @param notebookName Notebook name
     * @returns Action success status
     */
    clickToolbarItem(itemId: galata.NotebookToolbarItemId, notebookName?: string): Promise<boolean>;
    /**
     * Activate a notebook
     *
     * @param name Notebook name
     * @returns Action success status
     */
    activate(name: string): Promise<boolean>;
    /**
     * Save the currently active notebook
     *
     * @returns Action success status
     */
    save(): Promise<boolean>;
    /**
     * Revert changes to the currently active notebook
     *
     * @returns Action success status
     */
    revertChanges(): Promise<boolean>;
    /**
     * Run all cells of the currently active notebook
     *
     * @returns Action success status
     */
    run(): Promise<boolean>;
    /**
     * Run the currently active notebook cell by cell.
     *
     * @param callback Cell ran callback
     * @returns Action success status
     */
    runCellByCell(callback?: INotebookRunCallback): Promise<boolean>;
    /**
     * Trust the active notebook
     *
     * @returns Whether the action succeeded or not.
     */
    trust(): Promise<boolean>;
    /**
     * Wait for notebook cells execution to finish
     *
     * @param cellIndex Cell index
     */
    waitForRun(cellIndex?: number): Promise<void>;
    /**
     * Close the notebook with or without reverting unsaved changes
     *
     * @param revertChanges Whether to revert changes or not
     * @returns Action success status
     */
    close(revertChanges?: boolean): Promise<boolean>;
    /**
     * Get the number of cells in the currently active notebook
     *
     * @returns Number of cells
     */
    getCellCount: () => Promise<number>;
    /**
     * Get a cell handle
     *
     * @param cellIndex Cell index
     * @returns Handle to the cell
     *
     * @deprecated You should use locator instead {@link getCellLocator}
     */
    getCell(cellIndex: number): Promise<ElementHandle<Element> | null>;
    /**
     * Get a cell locator
     *
     * @param cellIndex Cell index
     * @param name Notebook name
     * @returns Handle to the cell
     */
    getCellLocator(cellIndex: number): Promise<Locator | null>;
    /**
     * Get the handle to the input of a cell
     *
     * @param cellIndex Cell index
     * @returns Handle to the cell input
     *
     * @deprecated You should use locator instead {@link getCellInputLocator}
     */
    getCellInput(cellIndex: number): Promise<ElementHandle<Element> | null>;
    /**
     * Get the locator to the input of a cell
     *
     * @param cellIndex Cell index
     * @returns Locator to the cell input
     */
    getCellInputLocator(cellIndex: number): Promise<Locator | null>;
    /**
     * Get the content of the cell input
     *
     * @param cellIndex Cell index
     * @returns the code input
     */
    getCellTextInput(cellIndex: number): Promise<string>;
    /**
     * Get the handle to the input expander of a cell
     *
     * @param cellIndex Cell index
     * @returns Handle to the cell input expander
     *
     * @deprecated You should use locator instead {@link getCellInputExpanderLocator}
     */
    getCellInputExpander(cellIndex: number): Promise<ElementHandle<Element> | null>;
    /**
     * Get the locator to the input expander of a cell
     *
     * @param cellIndex Cell index
     * @returns Locator to the cell input expander
     */
    getCellInputExpanderLocator(cellIndex: number): Promise<Locator | null>;
    /**
     * Whether a cell input is expanded or not
     *
     * @param cellIndex Cell index
     * @returns Cell input expanded status
     */
    isCellInputExpanded(cellIndex: number): Promise<boolean | null>;
    /**
     * Set the expanded status of a given input cell
     *
     * @param cellIndex Cell index
     * @param expand Input expanded status
     * @returns Action success status
     */
    expandCellInput(cellIndex: number, expand: boolean): Promise<boolean>;
    /**
     * Get the handle to a cell output expander
     *
     * @param cellIndex Cell index
     * @returns Handle to the cell output expander
     *
     * @deprecated You should use locator instead {@link getCellOutputExpanderLocator}
     */
    getCellOutputExpander(cellIndex: number): Promise<ElementHandle<Element> | null>;
    /**
     * Get the locator to a cell output expander
     *
     * @param cellIndex Cell index
     * @returns Handle to the cell output expander
     */
    getCellOutputExpanderLocator(cellIndex: number): Promise<Locator | null>;
    /**
     * Whether a cell output is expanded or not
     *
     * @param cellIndex Cell index
     * @returns Cell output expanded status
     */
    isCellOutputExpanded(cellIndex: number): Promise<boolean | null>;
    /**
     * Set the expanded status of a given output cell
     *
     * @param cellIndex Cell index
     * @param expand Output expanded status
     * @returns Action success status
     */
    expandCellOutput(cellIndex: number, expand: boolean): Promise<boolean>;
    /**
     * Get the handle on a given output cell
     *
     * @param cellIndex Cell index
     * @returns Output cell handle
     *
     * @deprecated You should use locator instead {@link getCellOutputLocator}
     */
    getCellOutput(cellIndex: number): Promise<ElementHandle<Element> | null>;
    /**
     * Get the locator on a given output cell
     *
     * @param cellIndex Cell index
     * @returns Locator cell handle
     */
    getCellOutputLocator(cellIndex: number): Promise<Locator | null>;
    /**
     * Get all cell outputs as text
     *
     * @param cellIndex Cell index
     * @returns List of text outputs
     */
    getCellTextOutput(cellIndex: number): Promise<string[] | null>;
    /**
     * Whether the cell is in editing mode or not.
     *
     * This method is not suitable for checking if a cell is unrendered
     * as it will return false when the cell is not active (not focused).
     *
     * @param cellIndex Cell index
     * @returns Editing mode
     */
    isCellInEditingMode(cellIndex: number): Promise<boolean>;
    private _setCellMode;
    /**
     * Enter the editing mode on a given cell
     *
     * @param cellIndex Cell index
     * @returns Action success status
     */
    enterCellEditingMode(cellIndex: number): Promise<boolean>;
    /**
     * Leave the editing mode
     *
     * @param cellIndex Cell index
     * @returns Action success status
     */
    leaveCellEditingMode(cellIndex: number): Promise<boolean>;
    /**
     * Clicks a cell gutter line for code cells
     *
     * @param cellIndex Cell index
     * @param lineNumber Cell line number, starts at 1
     */
    clickCellGutter(cellIndex: number, lineNumber: number): Promise<boolean>;
    /**
     * Check if cell gutter is present
     *
     * @param cellIndex
     */
    isCellGutterPresent(cellIndex: number): Promise<boolean>;
    /**
     * Wait until cell gutter is visible
     *
     * @param cellIndex
     */
    waitForCellGutter(cellIndex: number): Promise<void>;
    /**
     * Clicks a code gutter line for scripts
     *
     * @param lineNumber Cell line number, starts at 1
     */
    clickCodeGutter(lineNumber: number): Promise<boolean>;
    /**
     * Check if code gutter is present
     *
     */
    isCodeGutterPresent(): Promise<boolean>;
    /**
     * Wait until cell gutter is visible
     *
     * @param cellIndex
     */
    waitForCodeGutter(): Promise<void>;
    protected _clickOnGutter(panel: Locator, line: number): Promise<boolean>;
    /**
     * Select cells
     *
     * @param startIndex Start cell index
     * @param endIndex End cell index
     * @returns Action success status
     */
    selectCells(startIndex: number, endIndex?: number): Promise<boolean>;
    /**
     * Whether a given cell is selected or not
     *
     * @param cellIndex Cell index
     * @returns Selection status
     */
    isCellSelected(cellIndex: number): Promise<boolean>;
    /**
     * Delete selected cells
     *
     * @returns Action success status
     */
    deleteCells(): Promise<boolean>;
    /**
     * Add a cell to the currently active notebook
     *
     * @param cellType Cell type
     * @param source Source
     * @returns Action success status
     */
    addCell(cellType: nbformat.CellType, source: string): Promise<boolean>;
    /**
     * Set the input source of a cell
     *
     * @param cellIndex Cell index
     * @param cellType Cell type
     * @param source Source
     * @returns Action success status
     */
    setCell(cellIndex: number, cellType: nbformat.CellType, source: string): Promise<boolean>;
    /**
     * Set the type of a cell
     *
     * @param cellIndex Cell index
     * @param cellType Cell type
     * @returns Action success status
     */
    setCellType(cellIndex: number, cellType: nbformat.CellType): Promise<boolean>;
    /**
     * Get the cell type of a cell
     *
     * @param cellIndex Cell index
     * @returns Cell type
     */
    getCellType(cellIndex: number): Promise<nbformat.CellType | null>;
    /**
     * Get the cell type of a cell from its locator
     *
     * @param cell Cell locator
     * @returns Cell type
     */
    getCellLocatorType(cell: Locator): Promise<nbformat.CellType | null>;
    /**
     * Run a given cell
     *
     * @param cellIndex Cell index
     * @param inplace Whether to stay on the cell or select the next one
     * @returns Action success status
     */
    runCell(cellIndex: number, inplace?: boolean): Promise<boolean>;
    /**
     * Creates a new notebook.
     *
     * @param name - The name of the notebook. If provided, the notebook will be renamed to this name.
     * @param options - Parameters for creating the notebook.
     * @param options.kernel - The kernel to use for the notebook.
     * @returns A Promise that resolves to the name of the created notebook, or `null` if the notebook creation failed.
     */
    createNew(name?: string, options?: {
        kernel?: string | null;
    }): Promise<string | null>;
    private _runCallbacksExposed;
}
