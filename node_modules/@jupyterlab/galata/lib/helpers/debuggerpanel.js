"use strict";
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebuggerHelper = void 0;
const utils_1 = require("../utils");
/**
 * Debugger Helper
 */
class DebuggerHelper {
    constructor(page, sidebar, notebook) {
        this.page = page;
        this.sidebar = sidebar;
        this.notebook = notebook;
    }
    /**
     * Returns true if debugger toolbar item is enabled, false otherwise
     *
     * @param name Notebook name
     */
    async isOn(name) {
        var _a;
        const toolbar = await this.notebook.getToolbarLocator(name);
        const button = toolbar === null || toolbar === void 0 ? void 0 : toolbar.locator('.jp-DebuggerBugButton');
        if (((_a = (await (button === null || button === void 0 ? void 0 : button.count()))) !== null && _a !== void 0 ? _a : 0) > 0) {
            return (await button.getAttribute('aria-pressed')) === 'true';
        }
        return false;
    }
    /**
     * Enables the debugger toolbar item
     *
     * @param name Notebook name
     */
    async switchOn(name) {
        const toolbar = await this.notebook.getToolbarLocator(name);
        if (!toolbar) {
            return;
        }
        const button = toolbar.locator('.jp-DebuggerBugButton');
        await (0, utils_1.waitForCondition)(async () => (await button.count()) === 1);
        await (0, utils_1.waitForCondition)(async () => (await button.isDisabled()) === false, 2000);
        if (!(await this.isOn(name))) {
            await button.click();
        }
        await (0, utils_1.waitForCondition)(async () => await this.isOn(name));
    }
    /**
     * Disables the debugger toolbar item
     *
     * @param name Notebook name
     */
    async switchOff(name) {
        const toolbar = await this.notebook.getToolbarLocator(name);
        if (!toolbar) {
            return;
        }
        const button = toolbar.locator('.jp-DebuggerBugButton');
        await (0, utils_1.waitForCondition)(async () => (await button.count()) === 1);
        if (await this.isOn(name)) {
            await button.click();
        }
        await (0, utils_1.waitForCondition)(async () => !(await this.isOn(name)));
    }
    /**
     *  Returns true if debugger panel is open, false otherwise
     */
    async isOpen() {
        return await this.sidebar.isTabOpen('jp-debugger-sidebar');
    }
    /**
     * Returns handle to the variables panel content
     *
     * @deprecated You should use locator instead {@link getVariablesPanelLocator}
     */
    async getVariablesPanel() {
        return (await this.getVariablesPanelLocator()).elementHandle();
    }
    /**
     * Returns locator to the variables panel content
     */
    async getVariablesPanelLocator() {
        return this._getPanel('.jp-DebuggerVariables');
    }
    /**
     * Waits for variables to be populated in the variables panel
     */
    async waitForVariables() {
        await this.page
            .locator('.jp-DebuggerVariables-body')
            .getByRole('tree')
            .waitFor();
    }
    /**
     * render variable
     */
    async renderVariable(name) {
        await this.page
            .getByRole('treeitem', { name: `${name}:` })
            .click({ button: 'right' });
        await this.page.getByRole('menuitem', { name: 'Render Variable' }).click();
        await this.page.locator('.jp-VariableRendererPanel-renderer').waitFor();
    }
    /**
     * Returns handle to callstack panel content
     *
     * @deprecated You should use locator instead {@link getCallStackPanelLocator}
     */
    async getCallStackPanel() {
        return (await this.getCallStackPanelLocator()).elementHandle();
    }
    /**
     * Returns locator to callstack panel content
     */
    async getCallStackPanelLocator() {
        return this._getPanel('.jp-DebuggerCallstack');
    }
    /**
     * Waits for the callstack body to populate in the callstack panel
     */
    async waitForCallStack() {
        await this.page
            .locator('.jp-DebuggerCallstack-body >> .jp-DebuggerCallstackFrame')
            .first()
            .waitFor();
    }
    /**
     * Returns handle to breakpoints panel content
     *
     * @deprecated You should use locator instead {@link getBreakPointsPanelLocator}
     */
    async getBreakPointsPanel() {
        return (await this.getBreakPointsPanelLocator()).elementHandle();
    }
    /**
     * Returns locator to breakpoints panel content
     */
    async getBreakPointsPanelLocator() {
        return this._getPanel('.jp-DebuggerBreakpoints');
    }
    /**
     * Waits for the breakpoints to appear in the breakpoints panel
     */
    async waitForBreakPoints() {
        await this.page
            .locator('.jp-DebuggerBreakpoints >> .jp-DebuggerBreakpoint')
            .first()
            .waitFor();
    }
    /**
     * Returns handle to sources panel content
     *
     * @deprecated You should use locator instead {@link getSourcePanelLocator}
     */
    async getSourcePanel() {
        return (await this.getSourcePanelLocator()).elementHandle();
    }
    /**
     * Returns locator to sources panel content
     */
    async getSourcePanelLocator() {
        return this._getPanel('.jp-DebuggerSources');
    }
    /**
     * Waits for sources to be populated in the sources panel
     */
    async waitForSources() {
        await this.page
            .locator('.jp-DebuggerSources-body >> .jp-Editor')
            .first()
            .waitFor({ state: 'visible' });
    }
    async _getPanel(selector) {
        const panel = this.sidebar.getContentPanelLocator('right');
        return panel.locator(selector);
    }
}
exports.DebuggerHelper = DebuggerHelper;
//# sourceMappingURL=debuggerpanel.js.map