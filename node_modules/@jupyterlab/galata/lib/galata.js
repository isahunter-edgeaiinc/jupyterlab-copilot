"use strict";
/* eslint-disable camelcase */
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.galata = void 0;
const coreutils_1 = require("@lumino/coreutils");
const json5 = __importStar(require("json5"));
const contents_1 = require("./contents");
const helpers_1 = require("./helpers");
const jupyterlabpage_1 = require("./jupyterlabpage");
/**
 * Galata namespace
 */
var galata;
(function (galata) {
    /**
     * Default user settings:
     * - Deactivate codemirror cursor blinking to avoid noise in screenshots
     */
    galata.DEFAULT_SETTINGS = {
        '@jupyterlab/apputils-extension:notification': {
            checkForUpdates: false,
            fetchNews: 'false'
        },
        '@jupyterlab/fileeditor-extension:plugin': {},
        '@jupyterlab/notebook-extension:tracker': {},
        '@jupyterlab/codemirror-extension:plugin': {
            defaultConfig: {
                cursorBlinkRate: 0
            }
        },
        '@jupyterlab/terminal-extension:plugin': {
            cursorBlink: false
        }
    };
    galata.DEFAULT_DOCUMENTATION_STATE = {
        data: {
            'layout-restorer:data': {
                relativeSizes: [0, 1, 0]
            }
        }
    };
    /**
     * Add the Galata helpers to the page model
     *
     * @param page Playwright page model
     * @param baseURL Application base URL
     * @param waitForApplication Callback that resolved when the application page is ready
     * @param appPath Application URL path fragment
     * @returns Playwright page model with Galata helpers
     */
    function addHelpersToPage(page, baseURL, waitForApplication, appPath) {
        const jlabPage = new jupyterlabpage_1.JupyterLabPage(page, baseURL, waitForApplication, appPath);
        const handler = {
            get: function (obj, prop) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                return prop in obj ? obj[prop] : page[prop];
            }
        };
        // Proxy playwright page object
        return new Proxy(jlabPage, handler);
    }
    galata.addHelpersToPage = addHelpersToPage;
    async function initTestPage(appPath, autoGoto, baseURL, mockConfig, mockSettings, mockState, mockUser, page, sessions, terminals, tmpPath, waitForApplication, kernels) {
        // Hook the helpers
        const jlabWithPage = addHelpersToPage(page, baseURL, waitForApplication, appPath);
        // Add server mocks
        if (mockConfig) {
            const config = typeof mockConfig !== 'boolean' ? { ...mockConfig } : {};
            await Mock.mockConfig(page, config);
        }
        const settings = [];
        if (mockSettings) {
            // Settings will be stored in-memory (after loading the initial version from disk)
            await Mock.mockSettings(page, settings, typeof mockSettings === 'boolean' ? {} : { ...mockSettings });
        }
        const workspace = {
            data: {},
            metadata: { id: 'default' }
        };
        if (mockState) {
            if (typeof mockState !== 'boolean') {
                workspace.data = { ...mockState };
            }
            // State will be stored in-memory (after loading the initial version from disk)
            await Mock.mockState(page, workspace);
        }
        let user = {
            identity: {
                username: coreutils_1.UUID.uuid4(),
                name: 'jovyan',
                display_name: 'jovyan',
                initials: 'JP',
                color: 'var(--jp-collaborator-color1)'
            },
            permissions: {}
        };
        if (mockUser) {
            if (typeof mockUser !== 'boolean') {
                user = { ...mockUser };
            }
            // The user will be stored in-memory
            await Mock.mockUser(page, user);
        }
        // Add kernels, sessions and terminals trackers
        if (kernels) {
            await Mock.mockRunners(page, kernels, 'kernels');
        }
        if (sessions) {
            await Mock.mockRunners(page, sessions, 'sessions', kernels !== null && kernels !== void 0 ? kernels : undefined);
        }
        if (terminals) {
            await Mock.mockRunners(page, terminals, 'terminals');
        }
        if (autoGoto) {
            // Load and initialize JupyterLab and goto test folder
            await jlabWithPage.goto(`tree/${tmpPath}`);
        }
        return jlabWithPage;
    }
    galata.initTestPage = initTestPage;
    /**
     * Create a contents REST API helpers object
     *
     * @param request Playwright API request context
     * @param page Playwright page model
     * @returns Contents REST API helpers
     */
    function newContentsHelper(request, page) {
        return new contents_1.ContentsHelper(request, page);
    }
    galata.newContentsHelper = newContentsHelper;
    /**
     * Create a page with Galata helpers for the given browser in a new context.
     *
     * @returns Playwright page model with Galata helpers
     */
    async function newPage(options) {
        const { appPath, autoGoto, baseURL, browser, waitForApplication, mockConfig, mockKernels, mockSessions, mockSettings, mockState, mockTerminals, mockUser, tmpPath } = {
            appPath: '/lab',
            autoGoto: true,
            mockConfig: true,
            mockKernels: true,
            mockSessions: true,
            mockSettings: galata.DEFAULT_SETTINGS,
            mockState: true,
            mockTerminals: true,
            mockUser: true,
            tmpPath: '',
            ...options
        };
        const context = await browser.newContext();
        const page = await context.newPage();
        const kernels = mockKernels ? new Map() : null;
        const sessions = mockSessions ? new Map() : null;
        const terminals = mockTerminals
            ? new Map()
            : null;
        return {
            page: await initTestPage(appPath, autoGoto, baseURL, mockConfig, mockSettings, mockState, mockUser, page, sessions, terminals, tmpPath, waitForApplication, kernels),
            kernels,
            sessions,
            terminals
        };
    }
    galata.newPage = newPage;
    /**
     * Create a new performance helper
     *
     * @param page Playwright page model
     * @returns Performance helper
     */
    function newPerformanceHelper(page) {
        return new helpers_1.PerformanceHelper(page);
    }
    galata.newPerformanceHelper = newPerformanceHelper;
    /**
     * Regex to capture JupyterLab API call
     */
    let Routes;
    (function (Routes) {
        /**
         * Config API
         *
         * The config section can be found in the named group `section`.
         */
        Routes.config = /.*\/api\/config\/(?<section>\w+)/;
        /**
         * Contents API
         *
         * The content path can be found in the named group `path`.
         *
         * The path will be prefixed by '/'.
         * The path will be undefined for the root folder.
         */
        Routes.contents = /.*\/api\/contents(?<path>\/.+)?\?/;
        /**
         * Custom CSS
         */
        Routes.customCSS = /.*\/custom\/custom.css/;
        /**
         * Extensions API
         */
        Routes.extensions = /.*\/lab\/api\/extensions.*/;
        /**
         * Kernels API
         *
         * The kernel id can be found in the named group `id`.
         *
         * The id will be prefixed by '/'.
         */
        Routes.kernels = /.*\/api\/kernels(?!pecs)(?<id>\/[@:-\w]+)?/;
        /**
         * Sessions API
         *
         * The session id can be found in the named group `id`.
         *
         * The id will be prefixed by '/'.
         */
        Routes.sessions = /.*\/api\/sessions(?<id>\/[@:-\w]+)?/;
        /**
         * Settings API
         *
         * The schema name can be found in the named group `id`.
         *
         * The id will be prefixed by '/'.
         */
        Routes.settings = /.*\/api\/settings(?<id>(\/[@:-\w]+)*)/;
        /**
         * Terminals API
         *
         * The terminal id can be found in the named group `id`.
         *
         * The id will be prefixed by '/'.
         */
        Routes.terminals = /.*\/api\/terminals(?<id>\/[@:-\w]+)?/;
        /**
         * Translations API
         *
         * The locale can be found in the named group `id`.
         *
         * The id will be prefixed by '/'.
         */
        Routes.translations = /.*\/api\/translations(?<id>\/[@:-\w]+)?/;
        /**
         * Workspaces API
         *
         * The space name can be found in the named group `id`.
         *
         * The id will be prefixed by '/'.
         * The id will be undefined for workspaces listing route.
         */
        Routes.workspaces = /.*\/api\/workspaces(?<id>(\/[-\w]+)+)?/;
        /**
         * User API
         */
        Routes.user = /.*\/api\/me.*/;
    })(Routes = galata.Routes || (galata.Routes = {}));
    /**
     * Notebook generation helpers
     */
    let Notebook;
    (function (Notebook) {
        /**
         * Generate a notebook with identical cells
         *
         * @param nCells Number of cells
         * @param cellType Type of cells
         * @param defaultInput Default input source
         * @param defaultOutput Default outputs
         * @returns The notebook
         */
        function generateNotebook(nCells = 0, cellType = 'code', defaultInput = [], defaultOutput = []) {
            const cells = new Array();
            for (let i = 0; i < nCells; i++) {
                const execution_count = cellType === 'code'
                    ? defaultOutput.length > 0
                        ? i + 1
                        : null
                    : undefined;
                const cell = makeCell({
                    cell_type: cellType,
                    source: [...defaultInput],
                    outputs: cellType === 'code' ? [...defaultOutput] : undefined,
                    execution_count
                });
                cells.push(cell);
            }
            return makeNotebook(cells);
        }
        Notebook.generateNotebook = generateNotebook;
        /**
         * Generate a cell object
         *
         * @param skeleton Cell description template
         * @returns A cell
         */
        function makeCell(skeleton) {
            var _a;
            switch ((_a = skeleton.cell_type) !== null && _a !== void 0 ? _a : 'code') {
                case 'code':
                    return {
                        cell_type: 'code',
                        execution_count: null,
                        metadata: {},
                        outputs: [],
                        source: [],
                        ...skeleton
                    };
                default: {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const { execution_count, outputs, ...others } = skeleton;
                    return {
                        cell_type: 'markdown',
                        metadata: {},
                        source: [],
                        ...others
                    };
                }
            }
        }
        Notebook.makeCell = makeCell;
        /**
         * Generate a notebook object from a cell list
         *
         * @param cells Notebook cells
         * @returns Notebook
         */
        function makeNotebook(cells) {
            return {
                cells,
                metadata: {
                    kernelspec: {
                        display_name: 'Python 3',
                        language: 'python',
                        name: 'python3'
                    },
                    language_info: {
                        codemirror_mode: {
                            name: 'ipython',
                            version: 3
                        },
                        file_extension: '.py',
                        mimetype: 'text/x-python',
                        name: 'python',
                        nbconvert_exporter: 'python',
                        pygments_lexer: 'ipython3',
                        version: '3.8.0'
                    }
                },
                nbformat: 4,
                nbformat_minor: 4
            };
        }
        Notebook.makeNotebook = makeNotebook;
    })(Notebook = galata.Notebook || (galata.Notebook = {}));
    /**
     * Mock methods
     */
    let Mock;
    (function (Mock) {
        /**
         * Set last modified attributes one day ago one listing
         * directory content.
         *
         * @param page Page model object
         *
         * #### Notes
         * The goal is to freeze the file browser display
         */
        async function freezeContentLastModified(page, filter) {
            var _a;
            // Listen for closing connection (may happen when request are still being processed)
            let isClosed = false;
            const ctxt = page.context();
            ctxt.once('close', () => {
                isClosed = true;
            });
            (_a = ctxt.browser()) === null || _a === void 0 ? void 0 : _a.once('disconnected', () => {
                isClosed = true;
            });
            return page.route(Routes.contents, async (route, request) => {
                switch (request.method()) {
                    case 'GET': {
                        // Proxy the GET request
                        const response = await ctxt.request.fetch(request);
                        if (!response.ok()) {
                            if (!page.isClosed() && !isClosed) {
                                return route.fulfill({
                                    status: response.status(),
                                    body: await response.text()
                                });
                            }
                            break;
                        }
                        const data = await response.json();
                        // Modify the last_modified values to be set one day before now.
                        if (data['type'] === 'directory' &&
                            Array.isArray(data['content'])) {
                            if (filter) {
                                data['content'] = filter(data['content']);
                            }
                            const now = Date.now();
                            const aDayAgo = new Date(now - 24 * 3600 * 1000).toISOString();
                            for (const entry of data['content']) {
                                // Mutate the list in-place
                                entry['last_modified'] = aDayAgo;
                            }
                        }
                        if (!page.isClosed() && !isClosed) {
                            return route.fulfill({
                                status: 200,
                                body: JSON.stringify(data),
                                contentType: 'application/json'
                            });
                        }
                        break;
                    }
                    default:
                        return route.continue();
                }
            });
        }
        Mock.freezeContentLastModified = freezeContentLastModified;
        /**
         * Set a notebook's writable attribute to false
         *
         * @param page Page model object
         *
         * #### Notes
         * The goal is to have the notebook to appear as read-only
         */
        async function makeNotebookReadonly(page) {
            var _a;
            // Listen for closing connection (may happen when request are still being processed)
            let isClosed = false;
            const ctxt = page.context();
            ctxt.once('close', () => {
                isClosed = true;
            });
            (_a = ctxt.browser()) === null || _a === void 0 ? void 0 : _a.once('disconnected', () => {
                isClosed = true;
            });
            return page.route(Routes.contents, async (route, request) => {
                switch (request.method()) {
                    case 'GET': {
                        // Proxy the GET request
                        const response = await ctxt.request.fetch(request);
                        if (!response.ok()) {
                            if (!page.isClosed() && !isClosed) {
                                return route.fulfill({
                                    status: response.status(),
                                    body: await response.text()
                                });
                            }
                            break;
                        }
                        const data = await response.json();
                        if (data['type'] === 'notebook') {
                            data['writable'] = false;
                        }
                        if (!page.isClosed() && !isClosed) {
                            return route.fulfill({
                                status: 200,
                                body: JSON.stringify(data),
                                contentType: 'application/json'
                            });
                        }
                        break;
                    }
                    default:
                        return route.continue();
                }
            });
        }
        Mock.makeNotebookReadonly = makeNotebookReadonly;
        /**
         * Clear all wanted sessions or terminals.
         *
         * @param baseURL Application base URL
         * @param runners Session or terminal ids to stop
         * @param type Type of runner; session or terminal
         * @param request API request context
         * @returns Whether the runners were closed or not
         */
        async function clearRunners(request, runners, type) {
            const responses = await Promise.all([...new Set(runners)].map(id => request.fetch(`/api/${type}/${id}`, {
                method: 'DELETE'
            })));
            return responses.every(response => response.ok());
        }
        Mock.clearRunners = clearRunners;
        /**
         * Mock config route.
         *
         * @param page Page model object
         * @param config In-memory config
         */
        function mockConfig(page, config) {
            return page.route(Routes.config, (route, request) => {
                var _a, _b, _c, _d;
                const section = (_b = (_a = Routes.config.exec(request.url())) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.section;
                switch (request.method()) {
                    case 'GET':
                        return route.fulfill({
                            status: 200,
                            body: JSON.stringify((_c = config[section]) !== null && _c !== void 0 ? _c : {})
                        });
                    case 'PATCH': {
                        const data = request.postDataJSON();
                        // FIXME jupyter-server does a recursive update
                        // We are not doing it here as @jupyterlab/services is actually not recursively
                        // updating the object.
                        config[section] = { ...((_d = config[section]) !== null && _d !== void 0 ? _d : {}), ...data };
                        return route.fulfill({
                            status: 200,
                            body: JSON.stringify(config[section])
                        });
                    }
                    case 'PUT': {
                        const data = request.postDataJSON();
                        config[section] = data;
                        return route.fulfill({ status: 204 });
                    }
                    default:
                        return route.continue();
                }
            });
        }
        Mock.mockConfig = mockConfig;
        /**
         * Mock custom CSS.
         *
         * @param page Page model object
         * @param customCSS Custom CSS content
         */
        function mockCustomCSS(page, customCSS) {
            return page.route(Routes.customCSS, async (route, request) => {
                switch (request.method()) {
                    case 'GET':
                        return route.fulfill({
                            status: 200,
                            body: customCSS,
                            contentType: 'text/css'
                        });
                    default:
                        return route.continue();
                }
            });
        }
        Mock.mockCustomCSS = mockCustomCSS;
        const routes = {
            kernels: Routes.kernels,
            sessions: Routes.sessions,
            terminals: Routes.terminals
        };
        /**
         * Mock the runners API to display only those created during a test
         *
         * @param page Page model object
         * @param runners Mapping of current test runners
         * @param type Type of runner; session or terminal
         */
        function mockRunners(page, runners, type, kernels) {
            var _a;
            const routeRegex = routes[type];
            // Listen for closing connection (may happen when request are still being processed)
            let isClosed = false;
            const ctxt = page.context();
            ctxt.once('close', () => {
                isClosed = true;
            });
            (_a = ctxt.browser()) === null || _a === void 0 ? void 0 : _a.once('disconnected', () => {
                isClosed = true;
            });
            return page.route(routeRegex, async (route, request) => {
                var _a, _b, _c, _d, _e, _f;
                switch (request.method()) {
                    case 'DELETE': {
                        // slice is used to remove the '/' prefix
                        const id = (_c = (_b = (_a = routeRegex.exec(request.url())) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.id) === null || _c === void 0 ? void 0 : _c.slice(1);
                        await route.continue();
                        if (id && runners.has(id)) {
                            runners.delete(id);
                        }
                        break;
                    }
                    case 'GET': {
                        // slice is used to remove the '/' prefix
                        const id = (_f = (_e = (_d = routeRegex.exec(request.url())) === null || _d === void 0 ? void 0 : _d.groups) === null || _e === void 0 ? void 0 : _e.id) === null || _f === void 0 ? void 0 : _f.slice(1);
                        if (id) {
                            if (runners.has(id)) {
                                // Proxy the GET request
                                const response = await ctxt.request.fetch(request);
                                if (!response.ok()) {
                                    if (!page.isClosed() && !isClosed) {
                                        return route.fulfill({
                                            status: response.status(),
                                            body: await response.text()
                                        });
                                    }
                                    break;
                                }
                                const data = await response.json();
                                // Update stored runners
                                runners.set(type === 'terminals' ? data.name : data.id, data);
                                if (!page.isClosed() && !isClosed) {
                                    return route.fulfill({
                                        status: 200,
                                        body: JSON.stringify(data),
                                        contentType: 'application/json'
                                    });
                                }
                                break;
                            }
                            else {
                                if (!page.isClosed() && !isClosed) {
                                    return route.fulfill({
                                        status: 404
                                    });
                                }
                                break;
                            }
                        }
                        else {
                            // Proxy the GET request
                            const response = await ctxt.request.fetch(request);
                            if (!response.ok()) {
                                if (!page.isClosed() && !isClosed) {
                                    return route.fulfill({
                                        status: response.status(),
                                        body: await response.text()
                                    });
                                }
                                break;
                            }
                            const data = (await response.json());
                            const updated = new Set();
                            data.forEach(item => {
                                const itemID = type === 'terminals' ? item.name : item.id;
                                if (runners.has(itemID)) {
                                    updated.add(itemID);
                                    runners.set(itemID, item);
                                }
                            });
                            if (updated.size !== runners.size) {
                                for (const [runnerID] of runners) {
                                    if (!updated.has(runnerID)) {
                                        runners.delete(runnerID);
                                    }
                                }
                            }
                            if (!page.isClosed() && !isClosed) {
                                return route.fulfill({
                                    status: 200,
                                    body: JSON.stringify([...runners.values()]),
                                    contentType: 'application/json'
                                });
                            }
                            break;
                        }
                    }
                    case 'PATCH': {
                        // Proxy the PATCH request
                        const response = await ctxt.request.fetch(request);
                        if (!response.ok()) {
                            if (!page.isClosed() && !isClosed) {
                                return route.fulfill({
                                    status: response.status(),
                                    body: await response.text()
                                });
                            }
                            break;
                        }
                        const data = await response.json();
                        // Update stored runners
                        runners.set(type === 'terminals' ? data.name : data.id, data);
                        // Update kernels
                        if (kernels && type === 'sessions' && data.kernel.id) {
                            kernels.set(data.kernel.id, data.kernel);
                        }
                        if (!page.isClosed() && !isClosed) {
                            return route.fulfill({
                                status: 200,
                                body: JSON.stringify(data),
                                contentType: 'application/json'
                            });
                        }
                        break;
                    }
                    case 'POST': {
                        // Proxy the POST request
                        const response = await ctxt.request.fetch(request);
                        if (!response.ok()) {
                            if (!page.isClosed() && !isClosed) {
                                return route.fulfill({
                                    status: response.status(),
                                    body: await response.text()
                                });
                            }
                            break;
                        }
                        const data = await response.json();
                        const id = type === 'terminals' ? data.name : data.id;
                        runners.set(id, data);
                        // Update kernels
                        if (kernels && type === 'sessions' && data.kernel.id) {
                            kernels.set(data.kernel.id, data.kernel);
                        }
                        if (!page.isClosed() && !isClosed) {
                            return route.fulfill({
                                status: type === 'terminals' ? 200 : 201,
                                body: JSON.stringify(data),
                                contentType: 'application/json',
                                headers: response.headers
                            });
                        }
                        break;
                    }
                    default:
                        return route.continue();
                }
            });
        }
        Mock.mockRunners = mockRunners;
        /**
         * Mock workspace route.
         *
         * @param page Page model object
         * @param workspace In-memory workspace
         */
        function mockState(page, workspace) {
            return page.route(Routes.workspaces, (route, request) => {
                var _a, _b;
                switch (request.method()) {
                    case 'GET': {
                        const id = (_b = (_a = Routes.workspaces.exec(request.url())) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.id;
                        if (id) {
                            return route.fulfill({
                                status: 200,
                                body: JSON.stringify(workspace)
                            });
                        }
                        else {
                            return route.fulfill({
                                status: 200,
                                body: JSON.stringify({
                                    workspaces: {
                                        ids: [workspace.metadata.id],
                                        values: [workspace]
                                    }
                                })
                            });
                        }
                    }
                    case 'PUT': {
                        const data = request.postDataJSON();
                        workspace.data = { ...workspace.data, ...data.data };
                        workspace.metadata = { ...workspace.metadata, ...data.metadata };
                        return route.fulfill({ status: 204 });
                    }
                    default:
                        return route.continue();
                }
            });
        }
        Mock.mockState = mockState;
        /**
         * Settings REST API endpoint
         */
        const settingsRegex = Routes.settings;
        /**
         * Mock settings route.
         *
         * @param page Page model object
         * @param settings In-memory settings
         * @param mockedSettings Test mocked settings
         */
        function mockSettings(page, settings, mockedSettings) {
            var _a;
            // Listen for closing connection (may happen when request are still being processed)
            let isClosed = false;
            const ctxt = page.context();
            ctxt.once('close', () => {
                isClosed = true;
            });
            (_a = ctxt.browser()) === null || _a === void 0 ? void 0 : _a.once('disconnected', () => {
                isClosed = true;
            });
            return page.route(settingsRegex, async (route, request) => {
                var _a, _b, _c, _d, _e, _f;
                switch (request.method()) {
                    case 'GET': {
                        // slice is used to remove the '/' prefix
                        const id = (_b = (_a = settingsRegex.exec(request.url())) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.id.slice(1);
                        if (!id) {
                            // Get all settings
                            if (settings.length === 0) {
                                const response = await ctxt.request.fetch(request);
                                const loadedSettings = (await response.json())
                                    .settings;
                                settings.push(...loadedSettings.map(plugin => {
                                    var _a;
                                    const mocked = (_a = mockedSettings[plugin.id]) !== null && _a !== void 0 ? _a : {};
                                    return {
                                        ...plugin,
                                        raw: JSON.stringify(mocked),
                                        settings: mocked
                                    };
                                }));
                            }
                            if (!page.isClosed() && !isClosed) {
                                return route.fulfill({
                                    status: 200,
                                    body: JSON.stringify({ settings })
                                });
                            }
                            break;
                        }
                        else {
                            // Get specific settings
                            let pluginSettings = settings.find(setting => setting.id === id);
                            if (!pluginSettings) {
                                const response = await ctxt.request.fetch(request);
                                pluginSettings = await response.json();
                                if (pluginSettings) {
                                    const mocked = (_c = mockedSettings[id]) !== null && _c !== void 0 ? _c : {};
                                    pluginSettings = {
                                        ...pluginSettings,
                                        raw: JSON.stringify(mocked),
                                        settings: mocked
                                    };
                                    settings.push(pluginSettings);
                                }
                            }
                            if (!page.isClosed() && !isClosed) {
                                return route.fulfill({
                                    status: 200,
                                    body: JSON.stringify(pluginSettings)
                                });
                            }
                            break;
                        }
                    }
                    case 'PUT': {
                        // slice is used to remove the '/' prefix
                        const id = (_f = (_e = (_d = settingsRegex.exec(request.url())) === null || _d === void 0 ? void 0 : _d.groups) === null || _e === void 0 ? void 0 : _e.id) === null || _f === void 0 ? void 0 : _f.slice(1);
                        if (!id) {
                            return route.abort('addressunreachable');
                        }
                        const pluginSettings = settings.find(setting => setting.id === id);
                        const data = request.postDataJSON();
                        if (pluginSettings) {
                            pluginSettings.raw = data.raw;
                            try {
                                pluginSettings.settings = json5.parse(pluginSettings.raw);
                            }
                            catch (e) {
                                console.warn(`Failed to read raw settings ${pluginSettings.raw}`);
                                pluginSettings.settings = {};
                            }
                        }
                        else {
                            settings.push({
                                id,
                                ...data
                            });
                        }
                        // Stop mocking if a new version is pushed
                        delete mockedSettings[id];
                        return route.fulfill({
                            status: 204
                        });
                    }
                    default:
                        return route.continue();
                }
            });
        }
        Mock.mockSettings = mockSettings;
        /**
         * Mock user route.
         *
         * @param page Page model object
         * @param user In-memory user
         */
        function mockUser(page, user) {
            return page.route(Routes.user, (route, request) => {
                switch (request.method()) {
                    case 'GET':
                        return route.fulfill({
                            status: 200,
                            body: JSON.stringify(user)
                        });
                    default:
                        return route.continue();
                }
            });
        }
        Mock.mockUser = mockUser;
    })(Mock = galata.Mock || (galata.Mock = {}));
})(galata || (exports.galata = galata = {}));
//# sourceMappingURL=galata.js.map